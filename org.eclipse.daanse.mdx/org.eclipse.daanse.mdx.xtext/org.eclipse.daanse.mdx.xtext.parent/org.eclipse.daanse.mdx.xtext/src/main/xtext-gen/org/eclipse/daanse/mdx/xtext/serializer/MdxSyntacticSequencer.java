/*
 * generated by Xtext 2.27.0
 */
package org.eclipse.daanse.mdx.xtext.serializer;

import com.google.inject.Inject;
import java.util.List;
import org.eclipse.daanse.mdx.xtext.services.MdxGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.GroupAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.TokenAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynNavigable;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;

@SuppressWarnings("all")
public class MdxSyntacticSequencer extends AbstractSyntacticSequencer {

	protected MdxGrammarAccess grammarAccess;
	protected AbstractElementAlias match_SelectStatement_Axis_specification_listParserRuleCall_3_q;
	protected AbstractElementAlias match_SelectStatement_Cell_propsParserRuleCall_7_q;
	protected AbstractElementAlias match_SelectStatement___WHEREKeyword_6_0_Slicer_specificationParserRuleCall_6_1__q;
	protected AbstractElementAlias match_SelectStatement___WITHKeyword_1_0_FormulaSpecificationParserRuleCall_1_1__q;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (MdxGrammarAccess) access;
		match_SelectStatement_Axis_specification_listParserRuleCall_3_q = new TokenAlias(false, true, grammarAccess.getSelectStatementAccess().getAxis_specification_listParserRuleCall_3());
		match_SelectStatement_Cell_propsParserRuleCall_7_q = new TokenAlias(false, true, grammarAccess.getSelectStatementAccess().getCell_propsParserRuleCall_7());
		match_SelectStatement___WHEREKeyword_6_0_Slicer_specificationParserRuleCall_6_1__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getSelectStatementAccess().getWHEREKeyword_6_0()), new TokenAlias(false, false, grammarAccess.getSelectStatementAccess().getSlicer_specificationParserRuleCall_6_1()));
		match_SelectStatement___WITHKeyword_1_0_FormulaSpecificationParserRuleCall_1_1__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getSelectStatementAccess().getWITHKeyword_1_0()), new TokenAlias(false, false, grammarAccess.getSelectStatementAccess().getFormulaSpecificationParserRuleCall_1_1()));
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (ruleCall.getRule() == grammarAccess.getFormulaSpecificationRule())
			return getFormulaSpecificationToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getAxis_specification_listRule())
			return getaxis_specification_listToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCell_propsRule())
			return getcell_propsToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCube_specificationRule())
			return getcube_specificationToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSlicer_specificationRule())
			return getslicer_specificationToken(semanticObject, ruleCall, node);
		return "";
	}
	
	/**
	 * FormulaSpecification:
	 * 	single_formula_specification+;
	 */
	protected String getFormulaSpecificationToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "MEMBER DIMENSION AS \' NOT ,";
	}
	
	/**
	 * axis_specification_list:
	 * 	axis_specification (COMMA axis_specification)*;
	 */
	protected String getaxis_specification_listToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "NOT ON DIMENSION";
	}
	
	/**
	 * cell_props:
	 * 	'CELL'? 'PROPERTIES' cell_property_list;
	 */
	protected String getcell_propsToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "PROPERTIES CELL_ORDINAL ,";
	}
	
	/**
	 * cube_specification:
	 * 	cube_name;
	 */
	protected String getcube_specificationToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "DIMENSION";
	}
	
	/**
	 * slicer_specification:
	 * 	expression;
	 */
	protected String getslicer_specificationToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "NOT";
	}
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			if (match_SelectStatement_Axis_specification_listParserRuleCall_3_q.equals(syntax))
				emit_SelectStatement_Axis_specification_listParserRuleCall_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SelectStatement_Cell_propsParserRuleCall_7_q.equals(syntax))
				emit_SelectStatement_Cell_propsParserRuleCall_7_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SelectStatement___WHEREKeyword_6_0_Slicer_specificationParserRuleCall_6_1__q.equals(syntax))
				emit_SelectStatement___WHEREKeyword_6_0_Slicer_specificationParserRuleCall_6_1__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SelectStatement___WITHKeyword_1_0_FormulaSpecificationParserRuleCall_1_1__q.equals(syntax))
				emit_SelectStatement___WITHKeyword_1_0_FormulaSpecificationParserRuleCall_1_1__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     axis_specification_list?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) ('WITH' FormulaSpecification)? 'SELECT' (ambiguity) 'FROM' cube_specification ('WHERE' slicer_specification)? cell_props? (rule start)
	 
	 * </pre>
	 */
	protected void emit_SelectStatement_Axis_specification_listParserRuleCall_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     cell_props?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) ('WITH' FormulaSpecification)? 'SELECT' axis_specification_list? 'FROM' cube_specification ('WHERE' slicer_specification)? (ambiguity) (rule start)
	 
	 * </pre>
	 */
	protected void emit_SelectStatement_Cell_propsParserRuleCall_7_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     ('WHERE' slicer_specification)?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) ('WITH' FormulaSpecification)? 'SELECT' axis_specification_list? 'FROM' cube_specification (ambiguity) cell_props? (rule start)
	 
	 * </pre>
	 */
	protected void emit_SelectStatement___WHEREKeyword_6_0_Slicer_specificationParserRuleCall_6_1__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     ('WITH' FormulaSpecification)?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) 'SELECT' axis_specification_list? 'FROM' cube_specification ('WHERE' slicer_specification)? cell_props? (rule start)
	 
	 * </pre>
	 */
	protected void emit_SelectStatement___WITHKeyword_1_0_FormulaSpecificationParserRuleCall_1_1__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
}
